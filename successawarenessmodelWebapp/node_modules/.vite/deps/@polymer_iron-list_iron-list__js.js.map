{
  "version": 3,
  "sources": ["../../@polymer/iron-list/iron-list.js", "../../@polymer/iron-a11y-keys-behavior/iron-a11y-keys-behavior.js", "../../@polymer/iron-resizable-behavior/iron-resizable-behavior.js", "../../@polymer/iron-scroll-target-behavior/iron-scroll-target-behavior.js"],
  "sourcesContent": ["/**\n@license\nCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at\nhttp://polymer.github.io/LICENSE.txt The complete set of authors may be found at\nhttp://polymer.github.io/AUTHORS.txt The complete set of contributors may be\nfound at http://polymer.github.io/CONTRIBUTORS.txt Code distributed by Google as\npart of the polymer project is also subject to an additional IP rights grant\nfound at http://polymer.github.io/PATENTS.txt\n*/\nimport '@polymer/polymer/polymer-legacy.js';\nimport '@polymer/iron-a11y-keys-behavior/iron-a11y-keys-behavior.js';\n\nimport {IronResizableBehavior} from '@polymer/iron-resizable-behavior/iron-resizable-behavior.js';\nimport {IronScrollTargetBehavior} from '@polymer/iron-scroll-target-behavior/iron-scroll-target-behavior.js';\nimport {OptionalMutableDataBehavior} from '@polymer/polymer/lib/legacy/mutable-data-behavior.js';\nimport {Polymer as Polymer} from '@polymer/polymer/lib/legacy/polymer-fn.js';\nimport {dom} from '@polymer/polymer/lib/legacy/polymer.dom.js';\nimport {Templatizer} from '@polymer/polymer/lib/legacy/templatizer-behavior.js';\nimport {animationFrame, idlePeriod, microTask} from '@polymer/polymer/lib/utils/async.js';\nimport {Debouncer} from '@polymer/polymer/lib/utils/debounce.js';\nimport {enqueueDebouncer, flush} from '@polymer/polymer/lib/utils/flush.js';\nimport {html} from '@polymer/polymer/lib/utils/html-tag.js';\nimport {matches, translate} from '@polymer/polymer/lib/utils/path.js';\nimport {TemplateInstanceBase} from '@polymer/polymer/lib/utils/templatize.js';\n\nvar IOS = navigator.userAgent.match(/iP(?:hone|ad;(?: U;)? CPU) OS (\\d+)/);\nvar IOS_TOUCH_SCROLLING = IOS && IOS[1] >= 8;\nvar DEFAULT_PHYSICAL_COUNT = 3;\nvar HIDDEN_Y = '-10000px';\nvar SECRET_TABINDEX = -100;\n\n/**\n\n`iron-list` displays a virtual, 'infinite' list. The template inside\nthe iron-list element represents the DOM to create for each list item.\nThe `items` property specifies an array of list item data.\n\nFor performance reasons, not every item in the list is rendered at once;\ninstead a small subset of actual template elements *(enough to fill the\nviewport)* are rendered and reused as the user scrolls. As such, it is important\nthat all state of the list template is bound to the model driving it, since the\nview may be reused with a new model at any time. Particularly, any state that\nmay change as the result of a user interaction with the list item must be bound\nto the model to avoid view state inconsistency.\n\n### Sizing iron-list\n\n`iron-list` must either be explicitly sized, or delegate scrolling to an\nexplicitly sized parent. By \"explicitly sized\", we mean it either has an\nexplicit CSS `height` property set via a class or inline style, or else is sized\nby other layout means (e.g. the `flex` or `fit` classes).\n\n#### Flexbox - [jsbin](https://jsbin.com/vejoni/edit?html,output)\n\n```html\n<template is=\"x-list\">\n  <style>\n    :host {\n      display: block;\n      height: 100vh;\n      display: flex;\n      flex-direction: column;\n    }\n\n    iron-list {\n      flex: 1 1 auto;\n    }\n  </style>\n  <app-toolbar>App name</app-toolbar>\n  <iron-list items=\"[[items]]\">\n    <template>\n      <div>\n        ...\n      </div>\n    </template>\n  </iron-list>\n</template>\n```\n#### Explicit size - [jsbin](https://jsbin.com/vopucus/edit?html,output)\n```html\n<template is=\"x-list\">\n  <style>\n    :host {\n      display: block;\n    }\n\n    iron-list {\n      height: 100vh; /* don't use % values unless the parent element is sized.\n*\\/\n    }\n  </style>\n  <iron-list items=\"[[items]]\">\n    <template>\n      <div>\n        ...\n      </div>\n    </template>\n  </iron-list>\n</template>\n```\n#### Main document scrolling -\n[jsbin](https://jsbin.com/wevirow/edit?html,output)\n```html\n<head>\n  <style>\n    body {\n      height: 100vh;\n      margin: 0;\n      display: flex;\n      flex-direction: column;\n    }\n\n    app-toolbar {\n      position: fixed;\n      top: 0;\n      left: 0;\n      right: 0;\n    }\n\n    iron-list {\n      /* add padding since the app-toolbar is fixed at the top *\\/\n      padding-top: 64px;\n    }\n  </style>\n</head>\n<body>\n  <app-toolbar>App name</app-toolbar>\n  <iron-list scroll-target=\"document\">\n    <template>\n      <div>\n        ...\n      </div>\n    </template>\n  </iron-list>\n</body>\n```\n\n`iron-list` must be given a `<template>` which contains exactly one element. In\nthe examples above we used a `<div>`, but you can provide any element (including\ncustom elements).\n\n### Template model\n\nList item templates should bind to template models of the following structure:\n\n```js\n{\n  index: 0,        // index in the item array\n  selected: false, // true if the current item is selected\n  tabIndex: -1,    // a dynamically generated tabIndex for focus management\n  item: {}         // user data corresponding to items[index]\n}\n```\n\nAlternatively, you can change the property name used as data index by changing\nthe `indexAs` property. The `as` property defines the name of the variable to\nadd to the binding scope for the array.\n\nFor example, given the following `data` array:\n\n##### data.json\n\n```js\n[\n  {\"name\": \"Bob\"},\n  {\"name\": \"Tim\"},\n  {\"name\": \"Mike\"}\n]\n```\n\nThe following code would render the list (note the name property is bound from\nthe model object provided to the template scope):\n\n```html\n<iron-ajax url=\"data.json\" last-response=\"{{data}}\" auto></iron-ajax>\n<iron-list items=\"[[data]]\" as=\"item\">\n  <template>\n    <div>\n      Name: [[item.name]]\n    </div>\n  </template>\n</iron-list>\n```\n\n### Grid layout\n\n`iron-list` supports a grid layout in addition to linear layout by setting\nthe `grid` attribute.  In this case, the list template item must have both fixed\nwidth and height (e.g. via CSS). Based on this, the number of items\nper row are determined automatically based on the size of the list viewport.\n\n### Accessibility\n\n`iron-list` automatically manages the focus state for the items. It also\nprovides a `tabIndex` property within the template scope that can be used for\nkeyboard navigation. For example, users can press the up and down keys to move\nto previous and next items in the list:\n\n```html\n<iron-list items=\"[[data]]\" as=\"item\">\n  <template>\n    <div tabindex$=\"[[tabIndex]]\">\n      Name: [[item.name]]\n    </div>\n  </template>\n</iron-list>\n```\n\n### Styling\n\nYou can use the `--iron-list-items-container` mixin to style the container of\nitems:\n\n```css\niron-list {\n --iron-list-items-container: {\n    margin: auto;\n  };\n}\n```\n\n### Resizing\n\n`iron-list` lays out the items when it receives a notification via the\n`iron-resize` event. This event is fired by any element that implements\n`IronResizableBehavior`.\n\nBy default, elements such as `iron-pages`, `paper-tabs` or `paper-dialog` will\ntrigger this event automatically. If you hide the list manually (e.g. you use\n`display: none`) you might want to implement `IronResizableBehavior` or fire\nthis event manually right after the list became visible again. For example:\n\n```js\ndocument.querySelector('iron-list').fire('iron-resize');\n```\n\n### When should `<iron-list>` be used?\n\n`iron-list` should be used when a page has significantly more DOM nodes than the\nones visible on the screen. e.g. the page has 500 nodes, but only 20 are visible\nat a time. This is why we refer to it as a `virtual` list. In this case, a\n`dom-repeat` will still create 500 nodes which could slow down the web app, but\n`iron-list` will only create 20.\n\nHowever, having an `iron-list` does not mean that you can load all the data at\nonce. Say you have a million records in the database, you want to split the data\ninto pages so you can bring in a page at the time. The page could contain 500\nitems, and iron-list will only render 20.\n\n@element iron-list\n@demo demo/index.html\n\n*/\nPolymer({\n  /** @override */\n  _template: html`\n    <style>\n      :host {\n        display: block;\n      }\n\n      @media only screen and (-webkit-max-device-pixel-ratio: 1) {\n        :host {\n          will-change: transform;\n        }\n      }\n\n      #items {\n        @apply --iron-list-items-container;\n        position: relative;\n      }\n\n      :host(:not([grid])) #items > ::slotted(*) {\n        width: 100%;\n      }\n\n      #items > ::slotted(*) {\n        box-sizing: border-box;\n        margin: 0;\n        position: absolute;\n        top: 0;\n        will-change: transform;\n      }\n    </style>\n\n    <array-selector id=\"selector\" items=\"{{items}}\" selected=\"{{selectedItems}}\" selected-item=\"{{selectedItem}}\"></array-selector>\n\n    <div id=\"items\">\n      <slot></slot>\n    </div>\n`,\n\n  is: 'iron-list',\n\n  properties: {\n\n    /**\n     * An array containing items determining how many instances of the template\n     * to stamp and that that each template instance should bind to.\n     */\n    items: {type: Array},\n\n    /**\n     * The name of the variable to add to the binding scope for the array\n     * element associated with a given template instance.\n     */\n    as: {type: String, value: 'item'},\n\n    /**\n     * The name of the variable to add to the binding scope with the index\n     * for the row.\n     */\n    indexAs: {type: String, value: 'index'},\n\n    /**\n     * The name of the variable to add to the binding scope to indicate\n     * if the row is selected.\n     */\n    selectedAs: {type: String, value: 'selected'},\n\n    /**\n     * When true, the list is rendered as a grid. Grid items must have\n     * fixed width and height set via CSS. e.g.\n     *\n     * ```html\n     * <iron-list grid>\n     *   <template>\n     *      <div style=\"width: 100px; height: 100px;\"> 100x100 </div>\n     *   </template>\n     * </iron-list>\n     * ```\n     */\n    grid: {\n      type: Boolean,\n      value: false,\n      reflectToAttribute: true,\n      observer: '_gridChanged'\n    },\n\n    /**\n     * When true, tapping a row will select the item, placing its data model\n     * in the set of selected items retrievable via the selection property.\n     *\n     * Note that tapping focusable elements within the list item will not\n     * result in selection, since they are presumed to have their * own action.\n     */\n    selectionEnabled: {type: Boolean, value: false},\n\n    /**\n     * When `multiSelection` is false, this is the currently selected item, or\n     * `null` if no item is selected.\n     */\n    selectedItem: {type: Object, notify: true},\n\n    /**\n     * When `multiSelection` is true, this is an array that contains the\n     * selected items.\n     */\n    selectedItems: {type: Object, notify: true},\n\n    /**\n     * When `true`, multiple items may be selected at once (in this case,\n     * `selected` is an array of currently selected items).  When `false`,\n     * only one item may be selected at a time.\n     */\n    multiSelection: {type: Boolean, value: false},\n\n    /**\n     * The offset top from the scrolling element to the iron-list element.\n     * This value can be computed using the position returned by\n     * `getBoundingClientRect()` although it's preferred to use a constant value\n     * when possible.\n     *\n     * This property is useful when an external scrolling element is used and\n     * there's some offset between the scrolling element and the list. For\n     * example: a header is placed above the list.\n     */\n    scrollOffset: {type: Number, value: 0}\n  },\n\n  observers: [\n    '_itemsChanged(items.*)',\n    '_selectionEnabledChanged(selectionEnabled)',\n    '_multiSelectionChanged(multiSelection)',\n    '_setOverflow(scrollTarget, scrollOffset)'\n  ],\n\n  behaviors: [\n    Templatizer,\n    IronResizableBehavior,\n    IronScrollTargetBehavior,\n    OptionalMutableDataBehavior\n  ],\n\n  /**\n   * The ratio of hidden tiles that should remain in the scroll direction.\n   * Recommended value ~0.5, so it will distribute tiles evenly in both\n   * directions.\n   */\n  _ratio: 0.5,\n\n  /**\n   * The padding-top value for the list.\n   */\n  _scrollerPaddingTop: 0,\n\n  /**\n   * This value is a cached value of `scrollTop` from the last `scroll` event.\n   */\n  _scrollPosition: 0,\n\n  /**\n   * The sum of the heights of all the tiles in the DOM.\n   */\n  _physicalSize: 0,\n\n  /**\n   * The average `offsetHeight` of the tiles observed till now.\n   */\n  _physicalAverage: 0,\n\n  /**\n   * The number of tiles which `offsetHeight` > 0 observed until now.\n   */\n  _physicalAverageCount: 0,\n\n  /**\n   * The Y position of the item rendered in the `_physicalStart`\n   * tile relative to the scrolling list.\n   */\n  _physicalTop: 0,\n\n  /**\n   * The number of items in the list.\n   */\n  _virtualCount: 0,\n\n  /**\n   * The estimated scroll height based on `_physicalAverage`\n   */\n  _estScrollHeight: 0,\n\n  /**\n   * The scroll height of the dom node\n   */\n  _scrollHeight: 0,\n\n  /**\n   * The height of the list. This is referred as the viewport in the context of\n   * list.\n   */\n  _viewportHeight: 0,\n\n  /**\n   * The width of the list. This is referred as the viewport in the context of\n   * list.\n   */\n  _viewportWidth: 0,\n\n  /**\n   * An array of DOM nodes that are currently in the tree\n   * @type {?Array<!HTMLElement>}\n   */\n  _physicalItems: null,\n\n  /**\n   * An array of heights for each item in `_physicalItems`\n   * @type {?Array<number>}\n   */\n  _physicalSizes: null,\n\n  /**\n   * A cached value for the first visible index.\n   * See `firstVisibleIndex`\n   * @type {?number}\n   */\n  _firstVisibleIndexVal: null,\n\n  /**\n   * A cached value for the last visible index.\n   * See `lastVisibleIndex`\n   * @type {?number}\n   */\n  _lastVisibleIndexVal: null,\n\n  /**\n   * The max number of pages to render. One page is equivalent to the height of\n   * the list.\n   */\n  _maxPages: 2,\n\n  /**\n   * The currently focused physical item.\n   */\n  _focusedItem: null,\n\n  /**\n   * The virtual index of the focused item.\n   */\n  _focusedVirtualIndex: -1,\n\n  /**\n   * The physical index of the focused item.\n   */\n  _focusedPhysicalIndex: -1,\n\n  /**\n   * The the item that is focused if it is moved offscreen.\n   * @private {?HTMLElement}\n   */\n  _offscreenFocusedItem: null,\n\n  /**\n   * The item that backfills the `_offscreenFocusedItem` in the physical items\n   * list when that item is moved offscreen.\n   * @type {?HTMLElement}\n   */\n  _focusBackfillItem: null,\n\n  /**\n   * The maximum items per row\n   */\n  _itemsPerRow: 1,\n\n  /**\n   * The width of each grid item\n   */\n  _itemWidth: 0,\n\n  /**\n   * The height of the row in grid layout.\n   */\n  _rowHeight: 0,\n\n  /**\n   * The cost of stamping a template in ms.\n   */\n  _templateCost: 0,\n\n  /**\n   * Needed to pass event.model property to declarative event handlers -\n   * see polymer/polymer#4339.\n   */\n  _parentModel: true,\n\n  /**\n   * The bottom of the physical content.\n   */\n  get _physicalBottom() {\n    return this._physicalTop + this._physicalSize;\n  },\n\n  /**\n   * The bottom of the scroll.\n   */\n  get _scrollBottom() {\n    return this._scrollPosition + this._viewportHeight;\n  },\n\n  /**\n   * The n-th item rendered in the last physical item.\n   */\n  get _virtualEnd() {\n    return this._virtualStart + this._physicalCount - 1;\n  },\n\n  /**\n   * The height of the physical content that isn't on the screen.\n   */\n  get _hiddenContentSize() {\n    var size =\n        this.grid ? this._physicalRows * this._rowHeight : this._physicalSize;\n    return size - this._viewportHeight;\n  },\n\n  /**\n   * The parent node for the _userTemplate.\n   */\n  get _itemsParent() {\n    return dom(dom(this._userTemplate).parentNode);\n  },\n\n  /**\n   * The maximum scroll top value.\n   */\n  get _maxScrollTop() {\n    return this._estScrollHeight - this._viewportHeight + this._scrollOffset;\n  },\n\n  /**\n   * The largest n-th value for an item such that it can be rendered in\n   * `_physicalStart`.\n   */\n  get _maxVirtualStart() {\n    var virtualCount = this._convertIndexToCompleteRow(this._virtualCount);\n    return Math.max(0, virtualCount - this._physicalCount);\n  },\n\n  set _virtualStart(val) {\n    val = this._clamp(val, 0, this._maxVirtualStart);\n    if (this.grid) {\n      val = val - (val % this._itemsPerRow);\n    }\n    this._virtualStartVal = val;\n  },\n\n  get _virtualStart() {\n    return this._virtualStartVal || 0;\n  },\n\n  /**\n   * The k-th tile that is at the top of the scrolling list.\n   */\n  set _physicalStart(val) {\n    val = val % this._physicalCount;\n    if (val < 0) {\n      val = this._physicalCount + val;\n    }\n    if (this.grid) {\n      val = val - (val % this._itemsPerRow);\n    }\n    this._physicalStartVal = val;\n  },\n\n  get _physicalStart() {\n    return this._physicalStartVal || 0;\n  },\n\n  /**\n   * The k-th tile that is at the bottom of the scrolling list.\n   */\n  get _physicalEnd() {\n    return (this._physicalStart + this._physicalCount - 1) %\n        this._physicalCount;\n  },\n\n  set _physicalCount(val) {\n    this._physicalCountVal = val;\n  },\n\n  get _physicalCount() {\n    return this._physicalCountVal || 0;\n  },\n\n  /**\n   * An optimal physical size such that we will have enough physical items\n   * to fill up the viewport and recycle when the user scrolls.\n   *\n   * This default value assumes that we will at least have the equivalent\n   * to a viewport of physical items above and below the user's viewport.\n   */\n  get _optPhysicalSize() {\n    return this._viewportHeight === 0 ? Infinity :\n                                        this._viewportHeight * this._maxPages;\n  },\n\n  /**\n   * True if the current list is visible.\n   */\n  get _isVisible() {\n    return Boolean(this.offsetWidth || this.offsetHeight);\n  },\n\n  /**\n   * Gets the index of the first visible item in the viewport.\n   *\n   * @type {number}\n   */\n  get firstVisibleIndex() {\n    var idx = this._firstVisibleIndexVal;\n    if (idx == null) {\n      var physicalOffset = this._physicalTop + this._scrollOffset;\n\n      idx = this._iterateItems(function(pidx, vidx) {\n        physicalOffset += this._getPhysicalSizeIncrement(pidx);\n\n        if (physicalOffset > this._scrollPosition) {\n          return this.grid ? vidx - (vidx % this._itemsPerRow) : vidx;\n        }\n        // Handle a partially rendered final row in grid mode\n        if (this.grid && this._virtualCount - 1 === vidx) {\n          return vidx - (vidx % this._itemsPerRow);\n        }\n      }) ||\n          0;\n      this._firstVisibleIndexVal = idx;\n    }\n    return idx;\n  },\n\n  /**\n   * Gets the index of the last visible item in the viewport.\n   *\n   * @type {number}\n   */\n  get lastVisibleIndex() {\n    var idx = this._lastVisibleIndexVal;\n    if (idx == null) {\n      if (this.grid) {\n        idx = Math.min(\n            this._virtualCount,\n            this.firstVisibleIndex + this._estRowsInView * this._itemsPerRow -\n                1);\n      } else {\n        var physicalOffset = this._physicalTop + this._scrollOffset;\n        this._iterateItems(function(pidx, vidx) {\n          if (physicalOffset < this._scrollBottom) {\n            idx = vidx;\n          }\n          physicalOffset += this._getPhysicalSizeIncrement(pidx);\n        });\n      }\n      this._lastVisibleIndexVal = idx;\n    }\n    return idx;\n  },\n\n  get _defaultScrollTarget() {\n    return this;\n  },\n\n  get _virtualRowCount() {\n    return Math.ceil(this._virtualCount / this._itemsPerRow);\n  },\n\n  get _estRowsInView() {\n    return Math.ceil(this._viewportHeight / this._rowHeight);\n  },\n\n  get _physicalRows() {\n    return Math.ceil(this._physicalCount / this._itemsPerRow);\n  },\n\n  get _scrollOffset() {\n    return this._scrollerPaddingTop + this.scrollOffset;\n  },\n\n  /** @override */\n  ready: function() {\n    this.addEventListener('focus', this._didFocus.bind(this), true);\n  },\n\n  /** @override */\n  attached: function() {\n    this._debounce('_render', this._render, animationFrame);\n    // `iron-resize` is fired when the list is attached if the event is added\n    // before attached causing unnecessary work.\n    this.listen(this, 'iron-resize', '_resizeHandler');\n    this.listen(this, 'keydown', '_keydownHandler');\n  },\n\n  /** @override */\n  detached: function() {\n    this.unlisten(this, 'iron-resize', '_resizeHandler');\n    this.unlisten(this, 'keydown', '_keydownHandler');\n  },\n\n  /**\n   * Set the overflow property if this element has its own scrolling region\n   */\n  _setOverflow: function(scrollTarget) {\n    this.style.webkitOverflowScrolling = scrollTarget === this ? 'touch' : '';\n    this.style.overflowY = scrollTarget === this ? 'auto' : '';\n    // Clear cache.\n    this._lastVisibleIndexVal = null;\n    this._firstVisibleIndexVal = null;\n    this._debounce('_render', this._render, animationFrame);\n  },\n\n  /**\n   * Invoke this method if you dynamically update the viewport's\n   * size or CSS padding.\n   *\n   * @method updateViewportBoundaries\n   */\n  updateViewportBoundaries: function() {\n    var styles = window.getComputedStyle(this);\n    this._scrollerPaddingTop =\n        this.scrollTarget === this ? 0 : parseInt(styles['padding-top'], 10);\n    this._isRTL = Boolean(styles.direction === 'rtl');\n    this._viewportWidth = this.$.items.offsetWidth;\n    this._viewportHeight = this._scrollTargetHeight;\n    this.grid && this._updateGridMetrics();\n  },\n\n  /**\n   * Recycles the physical items when needed.\n   */\n  _scrollHandler: function() {\n    var scrollTop = Math.max(0, Math.min(this._maxScrollTop, this._scrollTop));\n    var delta = scrollTop - this._scrollPosition;\n    var isScrollingDown = delta >= 0;\n    // Track the current scroll position.\n    this._scrollPosition = scrollTop;\n    // Clear indexes for first and last visible indexes.\n    this._firstVisibleIndexVal = null;\n    this._lastVisibleIndexVal = null;\n    // Random access.\n    if (Math.abs(delta) > this._physicalSize && this._physicalSize > 0) {\n      delta = delta - this._scrollOffset;\n      var idxAdjustment =\n          Math.round(delta / this._physicalAverage) * this._itemsPerRow;\n      this._virtualStart = this._virtualStart + idxAdjustment;\n      this._physicalStart = this._physicalStart + idxAdjustment;\n      // Estimate new physical offset based on the virtual start index.\n      // adjusts the physical start position to stay in sync with the clamped\n      // virtual start index. It's critical not to let this value be\n      // more than the scroll position however, since that would result in\n      // the physical items not covering the viewport, and leading to\n      // _increasePoolIfNeeded to run away creating items to try to fill it.\n      this._physicalTop = Math.min(\n          Math.floor(this._virtualStart / this._itemsPerRow) *\n              this._physicalAverage,\n          this._scrollPosition);\n      this._update();\n    } else if (this._physicalCount > 0) {\n      var reusables = this._getReusables(isScrollingDown);\n      if (isScrollingDown) {\n        this._physicalTop = reusables.physicalTop;\n        this._virtualStart = this._virtualStart + reusables.indexes.length;\n        this._physicalStart = this._physicalStart + reusables.indexes.length;\n      } else {\n        this._virtualStart = this._virtualStart - reusables.indexes.length;\n        this._physicalStart = this._physicalStart - reusables.indexes.length;\n      }\n      this._update(\n          reusables.indexes, isScrollingDown ? null : reusables.indexes);\n      this._debounce(\n          '_increasePoolIfNeeded',\n          this._increasePoolIfNeeded.bind(this, 0),\n          microTask);\n    }\n  },\n\n  /**\n   * Returns an object that contains the indexes of the physical items\n   * that might be reused and the physicalTop.\n   *\n   * @param {boolean} fromTop If the potential reusable items are above the scrolling region.\n   */\n  _getReusables: function(fromTop) {\n    var ith, lastIth, offsetContent, physicalItemHeight;\n    var idxs = [];\n    var protectedOffsetContent = this._hiddenContentSize * this._ratio;\n    var virtualStart = this._virtualStart;\n    var virtualEnd = this._virtualEnd;\n    var physicalCount = this._physicalCount;\n    var top = this._physicalTop + this._scrollOffset;\n    var bottom = this._physicalBottom + this._scrollOffset;\n    // This may be called outside of a scrollHandler, so use last cached position\n    var scrollTop = this._scrollPosition;\n    var scrollBottom = this._scrollBottom;\n\n    if (fromTop) {\n      ith = this._physicalStart;\n      lastIth = this._physicalEnd;\n      offsetContent = scrollTop - top;\n    } else {\n      ith = this._physicalEnd;\n      lastIth = this._physicalStart;\n      offsetContent = bottom - scrollBottom;\n    }\n    while (true) {\n      physicalItemHeight = this._getPhysicalSizeIncrement(ith);\n      offsetContent = offsetContent - physicalItemHeight;\n      if (idxs.length >= physicalCount ||\n          offsetContent <= protectedOffsetContent) {\n        break;\n      }\n      if (fromTop) {\n        // Check that index is within the valid range.\n        if (virtualEnd + idxs.length + 1 >= this._virtualCount) {\n          break;\n        }\n        // Check that the index is not visible.\n        if (top + physicalItemHeight >= scrollTop - this._scrollOffset) {\n          break;\n        }\n        idxs.push(ith);\n        top = top + physicalItemHeight;\n        ith = (ith + 1) % physicalCount;\n      } else {\n        // Check that index is within the valid range.\n        if (virtualStart - idxs.length <= 0) {\n          break;\n        }\n        // Check that the index is not visible.\n        if (top + this._physicalSize - physicalItemHeight <= scrollBottom) {\n          break;\n        }\n        idxs.push(ith);\n        top = top - physicalItemHeight;\n        ith = (ith === 0) ? physicalCount - 1 : ith - 1;\n      }\n    }\n    return {indexes: idxs, physicalTop: top - this._scrollOffset};\n  },\n\n  /**\n   * Update the list of items, starting from the `_virtualStart` item.\n   * @param {!Array<number>=} itemSet\n   * @param {!Array<number>=} movingUp\n   */\n  _update: function(itemSet, movingUp) {\n    if ((itemSet && itemSet.length === 0) || this._physicalCount === 0) {\n      return;\n    }\n    this._manageFocus();\n    this._assignModels(itemSet);\n    this._updateMetrics(itemSet);\n    // Adjust offset after measuring.\n    if (movingUp) {\n      while (movingUp.length) {\n        var idx = movingUp.pop();\n        this._physicalTop -= this._getPhysicalSizeIncrement(idx);\n      }\n    }\n    this._positionItems();\n    this._updateScrollerSize();\n  },\n\n  /**\n   * Creates a pool of DOM elements and attaches them to the local dom.\n   *\n   * @param {number} size Size of the pool\n   */\n  _createPool: function(size) {\n    this._ensureTemplatized();\n    var i, inst;\n    var physicalItems = new Array(size);\n    for (i = 0; i < size; i++) {\n      inst = this.stamp(null);\n      // TODO(blasten):\n      // First element child is item; Safari doesn't support children[0]\n      // on a doc fragment. Test this to see if it still matters.\n      physicalItems[i] = inst.root.querySelector('*');\n      this._itemsParent.appendChild(inst.root);\n    }\n    return physicalItems;\n  },\n\n  _isClientFull: function() {\n    return this._scrollBottom != 0 &&\n        this._physicalBottom - 1 >= this._scrollBottom &&\n        this._physicalTop <= this._scrollPosition;\n  },\n\n  /**\n   * Increases the pool size.\n   */\n  _increasePoolIfNeeded: function(count) {\n    var nextPhysicalCount = this._clamp(\n        this._physicalCount + count,\n        DEFAULT_PHYSICAL_COUNT,\n        this._virtualCount - this._virtualStart);\n    nextPhysicalCount = this._convertIndexToCompleteRow(nextPhysicalCount);\n    if (this.grid) {\n      var correction = nextPhysicalCount % this._itemsPerRow;\n      if (correction && nextPhysicalCount - correction <= this._physicalCount) {\n        nextPhysicalCount += this._itemsPerRow;\n      }\n      nextPhysicalCount -= correction;\n    }\n    var delta = nextPhysicalCount - this._physicalCount;\n    var nextIncrease = Math.round(this._physicalCount * 0.5);\n\n    if (delta < 0) {\n      return;\n    }\n    if (delta > 0) {\n      var ts = window.performance.now();\n      // Concat arrays in place.\n      [].push.apply(this._physicalItems, this._createPool(delta));\n      // Push 0s into physicalSizes. Can't use Array.fill because IE11 doesn't\n      // support it.\n      for (var i = 0; i < delta; i++) {\n        this._physicalSizes.push(0);\n      }\n      this._physicalCount = this._physicalCount + delta;\n      // Update the physical start if it needs to preserve the model of the\n      // focused item. In this situation, the focused item is currently rendered\n      // and its model would have changed after increasing the pool if the\n      // physical start remained unchanged.\n      if (this._physicalStart > this._physicalEnd &&\n          this._isIndexRendered(this._focusedVirtualIndex) &&\n          this._getPhysicalIndex(this._focusedVirtualIndex) <\n              this._physicalEnd) {\n        this._physicalStart = this._physicalStart + delta;\n      }\n      this._update();\n      this._templateCost = (window.performance.now() - ts) / delta;\n      nextIncrease = Math.round(this._physicalCount * 0.5);\n    }\n    // The upper bounds is not fixed when dealing with a grid that doesn't\n    // fill it's last row with the exact number of items per row.\n    if (this._virtualEnd >= this._virtualCount - 1 || nextIncrease === 0) {\n      // Do nothing.\n    } else if (!this._isClientFull()) {\n      this._debounce(\n          '_increasePoolIfNeeded',\n          this._increasePoolIfNeeded.bind(this, nextIncrease),\n          microTask);\n    } else if (this._physicalSize < this._optPhysicalSize) {\n      // Yield and increase the pool during idle time until the physical size is\n      // optimal.\n      this._debounce(\n          '_increasePoolIfNeeded',\n          this._increasePoolIfNeeded.bind(\n              this,\n              this._clamp(\n                  Math.round(50 / this._templateCost), 1, nextIncrease)),\n          idlePeriod);\n    }\n  },\n\n  /**\n   * Renders the a new list.\n   */\n  _render: function() {\n    if (!this.isAttached || !this._isVisible) {\n      return;\n    }\n    if (this._physicalCount !== 0) {\n      var reusables = this._getReusables(true);\n      this._physicalTop = reusables.physicalTop;\n      this._virtualStart = this._virtualStart + reusables.indexes.length;\n      this._physicalStart = this._physicalStart + reusables.indexes.length;\n      this._update(reusables.indexes);\n      this._update();\n      this._increasePoolIfNeeded(0);\n    } else if (this._virtualCount > 0) {\n      // Initial render\n      this.updateViewportBoundaries();\n      this._increasePoolIfNeeded(DEFAULT_PHYSICAL_COUNT);\n    }\n  },\n\n  /**\n   * Templetizes the user template.\n   */\n  _ensureTemplatized: function() {\n    if (this.ctor) {\n      return;\n    }\n    this._userTemplate = /** @type {!HTMLTemplateElement} */ (\n        this.queryEffectiveChildren('template'));\n    if (!this._userTemplate) {\n      console.warn('iron-list requires a template to be provided in light-dom');\n    }\n    var instanceProps = {};\n    instanceProps.__key__ = true;\n    instanceProps[this.as] = true;\n    instanceProps[this.indexAs] = true;\n    instanceProps[this.selectedAs] = true;\n    instanceProps.tabIndex = true;\n    this._instanceProps = instanceProps;\n    this.templatize(this._userTemplate, this.mutableData);\n  },\n\n  _gridChanged: function(newGrid, oldGrid) {\n    if (typeof oldGrid === 'undefined')\n      return;\n    this.notifyResize();\n    flush();\n    newGrid && this._updateGridMetrics();\n  },\n\n  /**\n   * Called when the items have changed. That is, reassignments\n   * to `items`, splices or updates to a single item.\n   */\n  _itemsChanged: function(change) {\n    if (change.path === 'items') {\n      this._virtualStart = 0;\n      this._physicalTop = 0;\n      this._virtualCount = this.items ? this.items.length : 0;\n      this._physicalIndexForKey = {};\n      this._firstVisibleIndexVal = null;\n      this._lastVisibleIndexVal = null;\n      this._physicalCount = this._physicalCount || 0;\n      this._physicalItems = this._physicalItems || [];\n      this._physicalSizes = this._physicalSizes || [];\n      this._physicalStart = 0;\n      if (this._scrollTop > this._scrollOffset) {\n        this._resetScrollPosition(0);\n      }\n      this._removeFocusedItem();\n      this._debounce('_render', this._render, animationFrame);\n    } else if (change.path === 'items.splices') {\n      this._adjustVirtualIndex(change.value.indexSplices);\n      this._virtualCount = this.items ? this.items.length : 0;\n      // Only blur if at least one item is added or removed.\n      var itemAddedOrRemoved = change.value.indexSplices.some(function(splice) {\n        return splice.addedCount > 0 || splice.removed.length > 0;\n      });\n      if (itemAddedOrRemoved) {\n        // Only blur activeElement if it is a descendant of the list (#505,\n        // #507).\n        var activeElement = this._getActiveElement();\n        if (this.contains(activeElement)) {\n          activeElement.blur();\n        }\n      }\n      // Render only if the affected index is rendered.\n      var affectedIndexRendered =\n          change.value.indexSplices.some(function(splice) {\n            return splice.index + splice.addedCount >= this._virtualStart &&\n                splice.index <= this._virtualEnd;\n          }, this);\n      if (!this._isClientFull() || affectedIndexRendered) {\n        this._debounce('_render', this._render, animationFrame);\n      }\n    } else if (change.path !== 'items.length') {\n      this._forwardItemPath(change.path, change.value);\n    }\n  },\n\n  _forwardItemPath: function(path, value) {\n    path = path.slice(6);  // 'items.'.length == 6\n    var dot = path.indexOf('.');\n    if (dot === -1) {\n      dot = path.length;\n    }\n    var isIndexRendered;\n    var pidx;\n    var inst;\n    var offscreenInstance = this.modelForElement(this._offscreenFocusedItem);\n    var vidx = parseInt(path.substring(0, dot), 10);\n    isIndexRendered = this._isIndexRendered(vidx);\n    if (isIndexRendered) {\n      pidx = this._getPhysicalIndex(vidx);\n      inst = this.modelForElement(this._physicalItems[pidx]);\n    } else if (offscreenInstance) {\n      inst = offscreenInstance;\n    }\n\n    if (!inst || inst[this.indexAs] !== vidx) {\n      return;\n    }\n    path = path.substring(dot + 1);\n    path = this.as + (path ? '.' + path : '');\n    inst._setPendingPropertyOrPath(path, value, false, true);\n    inst._flushProperties && inst._flushProperties();\n    // TODO(blasten): V1 doesn't do this and it's a bug\n    if (isIndexRendered) {\n      this._updateMetrics([pidx]);\n      this._positionItems();\n      this._updateScrollerSize();\n    }\n  },\n\n  /**\n   * @param {!Array<!Object>} splices\n   */\n  _adjustVirtualIndex: function(splices) {\n    splices.forEach(function(splice) {\n      // deselect removed items\n      splice.removed.forEach(this._removeItem, this);\n      // We only need to care about changes happening above the current position\n      if (splice.index < this._virtualStart) {\n        var delta = Math.max(\n            splice.addedCount - splice.removed.length,\n            splice.index - this._virtualStart);\n        this._virtualStart = this._virtualStart + delta;\n        if (this._focusedVirtualIndex >= 0) {\n          this._focusedVirtualIndex = this._focusedVirtualIndex + delta;\n        }\n      }\n    }, this);\n  },\n\n  _removeItem: function(item) {\n    this.$.selector.deselect(item);\n    // remove the current focused item\n    if (this._focusedItem &&\n        this.modelForElement(this._focusedItem)[this.as] === item) {\n      this._removeFocusedItem();\n    }\n  },\n\n  /**\n   * Executes a provided function per every physical index in `itemSet`\n   * `itemSet` default value is equivalent to the entire set of physical\n   * indexes.\n   *\n   * @param {!function(number, number)} fn\n   * @param {!Array<number>=} itemSet\n   */\n  _iterateItems: function(fn, itemSet) {\n    var pidx, vidx, rtn, i;\n\n    if (arguments.length === 2 && itemSet) {\n      for (i = 0; i < itemSet.length; i++) {\n        pidx = itemSet[i];\n        vidx = this._computeVidx(pidx);\n        if ((rtn = fn.call(this, pidx, vidx)) != null) {\n          return rtn;\n        }\n      }\n    } else {\n      pidx = this._physicalStart;\n      vidx = this._virtualStart;\n      for (; pidx < this._physicalCount; pidx++, vidx++) {\n        if ((rtn = fn.call(this, pidx, vidx)) != null) {\n          return rtn;\n        }\n      }\n      for (pidx = 0; pidx < this._physicalStart; pidx++, vidx++) {\n        if ((rtn = fn.call(this, pidx, vidx)) != null) {\n          return rtn;\n        }\n      }\n    }\n  },\n\n  /**\n   * Returns the virtual index for a given physical index\n   *\n   * @param {number} pidx Physical index\n   * @return {number}\n   */\n  _computeVidx: function(pidx) {\n    if (pidx >= this._physicalStart) {\n      return this._virtualStart + (pidx - this._physicalStart);\n    }\n    return this._virtualStart + (this._physicalCount - this._physicalStart) +\n        pidx;\n  },\n\n  /**\n   * Assigns the data models to a given set of items.\n   * @param {!Array<number>=} itemSet\n   */\n  _assignModels: function(itemSet) {\n    this._iterateItems(function(pidx, vidx) {\n      var el = this._physicalItems[pidx];\n      var item = this.items && this.items[vidx];\n      if (item != null) {\n        var inst = this.modelForElement(el);\n        inst.__key__ = null;\n        this._forwardProperty(inst, this.as, item);\n        this._forwardProperty(\n            inst, this.selectedAs, this.$.selector.isSelected(item));\n        this._forwardProperty(inst, this.indexAs, vidx);\n        this._forwardProperty(\n            inst, 'tabIndex', this._focusedVirtualIndex === vidx ? 0 : -1);\n        this._physicalIndexForKey[inst.__key__] = pidx;\n        inst._flushProperties && inst._flushProperties(true);\n        el.removeAttribute('hidden');\n      } else {\n        el.setAttribute('hidden', '');\n      }\n    }, itemSet);\n  },\n\n  /**\n   * Updates the height for a given set of items.\n   *\n   * @param {!Array<number>=} itemSet\n   */\n  _updateMetrics: function(itemSet) {\n    // Make sure we distributed all the physical items\n    // so we can measure them.\n    flush();\n\n    var newPhysicalSize = 0;\n    var oldPhysicalSize = 0;\n    var prevAvgCount = this._physicalAverageCount;\n    var prevPhysicalAvg = this._physicalAverage;\n\n    this._iterateItems(function(pidx, vidx) {\n      oldPhysicalSize += this._physicalSizes[pidx];\n      this._physicalSizes[pidx] = this._physicalItems[pidx].offsetHeight;\n      newPhysicalSize += this._physicalSizes[pidx];\n      this._physicalAverageCount += this._physicalSizes[pidx] ? 1 : 0;\n    }, itemSet);\n\n    if (this.grid) {\n      this._updateGridMetrics();\n      this._physicalSize =\n          Math.ceil(this._physicalCount / this._itemsPerRow) * this._rowHeight;\n    } else {\n      oldPhysicalSize = (this._itemsPerRow === 1) ?\n          oldPhysicalSize :\n          Math.ceil(this._physicalCount / this._itemsPerRow) * this._rowHeight;\n      this._physicalSize =\n          this._physicalSize + newPhysicalSize - oldPhysicalSize;\n      this._itemsPerRow = 1;\n    }\n    // Update the average if it measured something.\n    if (this._physicalAverageCount !== prevAvgCount) {\n      this._physicalAverage = Math.round(\n          ((prevPhysicalAvg * prevAvgCount) + newPhysicalSize) /\n          this._physicalAverageCount);\n    }\n  },\n\n  _updateGridMetrics: function() {\n    this._itemWidth = this._physicalCount > 0 ?\n        this._physicalItems[0].getBoundingClientRect().width :\n        200;\n    this._rowHeight =\n        this._physicalCount > 0 ? this._physicalItems[0].offsetHeight : 200;\n    this._itemsPerRow = this._itemWidth ?\n        Math.floor(this._viewportWidth / this._itemWidth) :\n        this._itemsPerRow;\n  },\n\n  /**\n   * Updates the position of the physical items.\n   */\n  _positionItems: function() {\n    this._adjustScrollPosition();\n\n    var y = this._physicalTop;\n\n    if (this.grid) {\n      var totalItemWidth = this._itemsPerRow * this._itemWidth;\n      var rowOffset = (this._viewportWidth - totalItemWidth) / 2;\n\n      this._iterateItems(function(pidx, vidx) {\n        var modulus = vidx % this._itemsPerRow;\n        var x = Math.floor((modulus * this._itemWidth) + rowOffset);\n        if (this._isRTL) {\n          x = x * -1;\n        }\n        this.translate3d(x + 'px', y + 'px', 0, this._physicalItems[pidx]);\n        if (this._shouldRenderNextRow(vidx)) {\n          y += this._rowHeight;\n        }\n      });\n    } else {\n      const order = [];\n      this._iterateItems(function(pidx, vidx) {\n        const item = this._physicalItems[pidx];\n        this.translate3d(0, y + 'px', 0, item);\n        y += this._physicalSizes[pidx];\n        const itemId = item.id;\n        if (itemId) {\n          order.push(itemId);\n        }\n      });\n      if (order.length) {\n        this.setAttribute('aria-owns', order.join(' '));\n      }\n    }\n  },\n\n  _getPhysicalSizeIncrement: function(pidx) {\n    if (!this.grid) {\n      return this._physicalSizes[pidx];\n    }\n    if (this._computeVidx(pidx) % this._itemsPerRow !== this._itemsPerRow - 1) {\n      return 0;\n    }\n    return this._rowHeight;\n  },\n\n  /**\n   * Returns, based on the current index,\n   * whether or not the next index will need\n   * to be rendered on a new row.\n   *\n   * @param {number} vidx Virtual index\n   * @return {boolean}\n   */\n  _shouldRenderNextRow: function(vidx) {\n    return vidx % this._itemsPerRow === this._itemsPerRow - 1;\n  },\n\n  /**\n   * Adjusts the scroll position when it was overestimated.\n   */\n  _adjustScrollPosition: function() {\n    var deltaHeight = this._virtualStart === 0 ?\n        this._physicalTop :\n        Math.min(this._scrollPosition + this._physicalTop, 0);\n    // Note: the delta can be positive or negative.\n    if (deltaHeight !== 0) {\n      this._physicalTop = this._physicalTop - deltaHeight;\n      // This may be called outside of a scrollHandler, so use last cached position\n      var scrollTop = this._scrollPosition;\n      // juking scroll position during interial scrolling on iOS is no bueno\n      if (!IOS_TOUCH_SCROLLING && scrollTop > 0) {\n        this._resetScrollPosition(scrollTop - deltaHeight);\n      }\n    }\n  },\n\n  /**\n   * Sets the position of the scroll.\n   */\n  _resetScrollPosition: function(pos) {\n    if (this.scrollTarget && pos >= 0) {\n      this._scrollTop = pos;\n      this._scrollPosition = this._scrollTop;\n    }\n  },\n\n  /**\n   * Sets the scroll height, that's the height of the content,\n   *\n   * @param {boolean=} forceUpdate If true, updates the height no matter what.\n   */\n  _updateScrollerSize: function(forceUpdate) {\n    if (this.grid) {\n      this._estScrollHeight = this._virtualRowCount * this._rowHeight;\n    } else {\n      this._estScrollHeight =\n          (this._physicalBottom +\n           Math.max(\n               this._virtualCount - this._physicalCount - this._virtualStart,\n               0) *\n               this._physicalAverage);\n    }\n    forceUpdate = forceUpdate || this._scrollHeight === 0;\n    forceUpdate = forceUpdate ||\n        this._scrollPosition >= this._estScrollHeight - this._physicalSize;\n    forceUpdate = forceUpdate ||\n        this.grid && this.$.items.style.height < this._estScrollHeight;\n    // Amortize height adjustment, so it won't trigger large repaints too often.\n    if (forceUpdate ||\n        Math.abs(this._estScrollHeight - this._scrollHeight) >=\n            this._viewportHeight) {\n      this.$.items.style.height = this._estScrollHeight + 'px';\n      this._scrollHeight = this._estScrollHeight;\n    }\n  },\n\n  /**\n   * Scroll to a specific item in the virtual list regardless\n   * of the physical items in the DOM tree.\n   *\n   * @method scrollToItem\n   * @param {(Object)} item The item to be scrolled to\n   */\n  scrollToItem: function(item) {\n    return this.scrollToIndex(this.items.indexOf(item));\n  },\n\n  /**\n   * Scroll to a specific index in the virtual list regardless\n   * of the physical items in the DOM tree.\n   *\n   * @method scrollToIndex\n   * @param {number} idx The index of the item\n   */\n  scrollToIndex: function(idx) {\n    if (typeof idx !== 'number' || idx < 0 || idx > this.items.length - 1) {\n      return;\n    }\n    flush();\n    // Items should have been rendered prior scrolling to an index.\n    if (this._physicalCount === 0) {\n      return;\n    }\n    idx = this._clamp(idx, 0, this._virtualCount - 1);\n    // Update the virtual start only when needed.\n    if (!this._isIndexRendered(idx) || idx >= this._maxVirtualStart) {\n      this._virtualStart =\n          this.grid ? (idx - this._itemsPerRow * 2) : (idx - 1);\n    }\n    this._manageFocus();\n    this._assignModels();\n    this._updateMetrics();\n    // Estimate new physical offset.\n    this._physicalTop = Math.floor(this._virtualStart / this._itemsPerRow) *\n        this._physicalAverage;\n\n    var currentTopItem = this._physicalStart;\n    var currentVirtualItem = this._virtualStart;\n    var targetOffsetTop = 0;\n    var hiddenContentSize = this._hiddenContentSize;\n    // scroll to the item as much as we can.\n    while (currentVirtualItem < idx && targetOffsetTop <= hiddenContentSize) {\n      targetOffsetTop =\n          targetOffsetTop + this._getPhysicalSizeIncrement(currentTopItem);\n      currentTopItem = (currentTopItem + 1) % this._physicalCount;\n      currentVirtualItem++;\n    }\n    this._updateScrollerSize(true);\n    this._positionItems();\n    this._resetScrollPosition(\n        this._physicalTop + this._scrollOffset + targetOffsetTop);\n    this._increasePoolIfNeeded(0);\n    // clear cached visible index.\n    this._firstVisibleIndexVal = null;\n    this._lastVisibleIndexVal = null;\n  },\n\n  /**\n   * Reset the physical average and the average count.\n   */\n  _resetAverage: function() {\n    this._physicalAverage = 0;\n    this._physicalAverageCount = 0;\n  },\n\n  /**\n   * A handler for the `iron-resize` event triggered by `IronResizableBehavior`\n   * when the element is resized.\n   */\n  _resizeHandler: function() {\n    this._debounce('_render', function() {\n      // clear cached visible index.\n      this._firstVisibleIndexVal = null;\n      this._lastVisibleIndexVal = null;\n      if (this._isVisible) {\n        this.updateViewportBoundaries();\n        // Reinstall the scroll event listener.\n        this.toggleScrollListener(true);\n        this._resetAverage();\n        this._render();\n      } else {\n        // Uninstall the scroll event listener.\n        this.toggleScrollListener(false);\n      }\n    }, animationFrame);\n  },\n\n  /**\n   * Selects the given item.\n   *\n   * @method selectItem\n   * @param {Object} item The item instance.\n   */\n  selectItem: function(item) {\n    return this.selectIndex(this.items.indexOf(item));\n  },\n\n  /**\n   * Selects the item at the given index in the items array.\n   *\n   * @method selectIndex\n   * @param {number} index The index of the item in the items array.\n   */\n  selectIndex: function(index) {\n    if (index < 0 || index >= this._virtualCount) {\n      return;\n    }\n    if (!this.multiSelection && this.selectedItem) {\n      this.clearSelection();\n    }\n    if (this._isIndexRendered(index)) {\n      var model = this.modelForElement(\n          this._physicalItems[this._getPhysicalIndex(index)]);\n      if (model) {\n        model[this.selectedAs] = true;\n      }\n      this.updateSizeForIndex(index);\n    }\n    this.$.selector.selectIndex(index);\n  },\n\n  /**\n   * Deselects the given item.\n   *\n   * @method deselect\n   * @param {Object} item The item instance.\n   */\n  deselectItem: function(item) {\n    return this.deselectIndex(this.items.indexOf(item));\n  },\n\n  /**\n   * Deselects the item at the given index in the items array.\n   *\n   * @method deselectIndex\n   * @param {number} index The index of the item in the items array.\n   */\n  deselectIndex: function(index) {\n    if (index < 0 || index >= this._virtualCount) {\n      return;\n    }\n    if (this._isIndexRendered(index)) {\n      var model = this.modelForElement(\n          this._physicalItems[this._getPhysicalIndex(index)]);\n      model[this.selectedAs] = false;\n      this.updateSizeForIndex(index);\n    }\n    this.$.selector.deselectIndex(index);\n  },\n\n  /**\n   * Selects or deselects a given item depending on whether the item\n   * has already been selected.\n   *\n   * @method toggleSelectionForItem\n   * @param {Object} item The item object.\n   */\n  toggleSelectionForItem: function(item) {\n    return this.toggleSelectionForIndex(this.items.indexOf(item));\n  },\n\n  /**\n   * Selects or deselects the item at the given index in the items array\n   * depending on whether the item has already been selected.\n   *\n   * @method toggleSelectionForIndex\n   * @param {number} index The index of the item in the items array.\n   */\n  toggleSelectionForIndex: function(index) {\n    var isSelected = this.$.selector.isIndexSelected ?\n        this.$.selector.isIndexSelected(index) :\n        this.$.selector.isSelected(this.items[index]);\n    isSelected ? this.deselectIndex(index) : this.selectIndex(index);\n  },\n\n  /**\n   * Clears the current selection in the list.\n   *\n   * @method clearSelection\n   */\n  clearSelection: function() {\n    this._iterateItems(function(pidx, vidx) {\n      this.modelForElement(this._physicalItems[pidx])[this.selectedAs] = false;\n    });\n    this.$.selector.clearSelection();\n  },\n\n  /**\n   * Add an event listener to `tap` if `selectionEnabled` is true,\n   * it will remove the listener otherwise.\n   */\n  _selectionEnabledChanged: function(selectionEnabled) {\n    var handler = selectionEnabled ? this.listen : this.unlisten;\n    handler.call(this, this, 'tap', '_selectionHandler');\n  },\n\n  /**\n   * Select an item from an event object.\n   */\n  _selectionHandler: function(e) {\n    var model = this.modelForElement(e.target);\n    if (!model) {\n      return;\n    }\n    var modelTabIndex, activeElTabIndex;\n    var target = dom(e).path[0];\n    var activeEl = this._getActiveElement();\n    var physicalItem =\n        this._physicalItems[this._getPhysicalIndex(model[this.indexAs])];\n    // Safari does not focus certain form controls via mouse\n    // https://bugs.webkit.org/show_bug.cgi?id=118043\n    if (target.localName === 'input' || target.localName === 'button' ||\n        target.localName === 'select') {\n      return;\n    }\n    // Set a temporary tabindex\n    modelTabIndex = model.tabIndex;\n    model.tabIndex = SECRET_TABINDEX;\n    activeElTabIndex = activeEl ? activeEl.tabIndex : -1;\n    model.tabIndex = modelTabIndex;\n    // Only select the item if the tap wasn't on a focusable child\n    // or the element bound to `tabIndex`\n    if (activeEl && physicalItem !== activeEl &&\n        physicalItem.contains(activeEl) &&\n        activeElTabIndex !== SECRET_TABINDEX) {\n      return;\n    }\n    this.toggleSelectionForItem(model[this.as]);\n  },\n\n  _multiSelectionChanged: function(multiSelection) {\n    this.clearSelection();\n    this.$.selector.multi = multiSelection;\n  },\n\n  /**\n   * Updates the size of a given list item.\n   *\n   * @method updateSizeForItem\n   * @param {Object} item The item instance.\n   */\n  updateSizeForItem: function(item) {\n    return this.updateSizeForIndex(this.items.indexOf(item));\n  },\n\n  /**\n   * Updates the size of the item at the given index in the items array.\n   *\n   * @method updateSizeForIndex\n   * @param {number} index The index of the item in the items array.\n   */\n  updateSizeForIndex: function(index) {\n    if (!this._isIndexRendered(index)) {\n      return null;\n    }\n    this._updateMetrics([this._getPhysicalIndex(index)]);\n    this._positionItems();\n    return null;\n  },\n\n  /**\n   * Creates a temporary backfill item in the rendered pool of physical items\n   * to replace the main focused item. The focused item has tabIndex = 0\n   * and might be currently focused by the user.\n   *\n   * This dynamic replacement helps to preserve the focus state.\n   */\n  _manageFocus: function() {\n    var fidx = this._focusedVirtualIndex;\n\n    if (fidx >= 0 && fidx < this._virtualCount) {\n      // if it's a valid index, check if that index is rendered\n      // in a physical item.\n      if (this._isIndexRendered(fidx)) {\n        this._restoreFocusedItem();\n      } else {\n        this._createFocusBackfillItem();\n      }\n    } else if (this._virtualCount > 0 && this._physicalCount > 0) {\n      // otherwise, assign the initial focused index.\n      this._focusedPhysicalIndex = this._physicalStart;\n      this._focusedVirtualIndex = this._virtualStart;\n      this._focusedItem = this._physicalItems[this._physicalStart];\n    }\n  },\n\n  /**\n   * Converts a random index to the index of the item that completes it's row.\n   * Allows for better order and fill computation when grid == true.\n   */\n  _convertIndexToCompleteRow: function(idx) {\n    // when grid == false _itemPerRow can be unset.\n    this._itemsPerRow = this._itemsPerRow || 1;\n    return this.grid ? Math.ceil(idx / this._itemsPerRow) * this._itemsPerRow :\n                       idx;\n  },\n\n  _isIndexRendered: function(idx) {\n    return idx >= this._virtualStart && idx <= this._virtualEnd;\n  },\n\n  _isIndexVisible: function(idx) {\n    return idx >= this.firstVisibleIndex && idx <= this.lastVisibleIndex;\n  },\n\n  _getPhysicalIndex: function(vidx) {\n    return (this._physicalStart + (vidx - this._virtualStart)) %\n        this._physicalCount;\n  },\n\n  focusItem: function(idx) {\n    this._focusPhysicalItem(idx);\n  },\n\n  _focusPhysicalItem: function(idx) {\n    if (idx < 0 || idx >= this._virtualCount) {\n      return;\n    }\n    this._restoreFocusedItem();\n    // scroll to index to make sure it's rendered\n    if (!this._isIndexRendered(idx)) {\n      this.scrollToIndex(idx);\n    }\n    var physicalItem = this._physicalItems[this._getPhysicalIndex(idx)];\n    var model = this.modelForElement(physicalItem);\n    var focusable;\n    // set a secret tab index\n    model.tabIndex = SECRET_TABINDEX;\n    // check if focusable element is the physical item\n    if (physicalItem.tabIndex === SECRET_TABINDEX) {\n      focusable = physicalItem;\n    }\n    // search for the element which tabindex is bound to the secret tab index\n    if (!focusable) {\n      focusable = dom(physicalItem)\n                      .querySelector('[tabindex=\"' + SECRET_TABINDEX + '\"]');\n    }\n    // restore the tab index\n    model.tabIndex = 0;\n    // focus the focusable element\n    this._focusedVirtualIndex = idx;\n    focusable && focusable.focus();\n  },\n\n  _removeFocusedItem: function() {\n    if (this._offscreenFocusedItem) {\n      this._itemsParent.removeChild(this._offscreenFocusedItem);\n    }\n    this._offscreenFocusedItem = null;\n    this._focusBackfillItem = null;\n    this._focusedItem = null;\n    this._focusedVirtualIndex = -1;\n    this._focusedPhysicalIndex = -1;\n  },\n\n  _createFocusBackfillItem: function() {\n    var fpidx = this._focusedPhysicalIndex;\n\n    if (this._offscreenFocusedItem || this._focusedVirtualIndex < 0) {\n      return;\n    }\n    if (!this._focusBackfillItem) {\n      // Create a physical item.\n      var inst = this.stamp(null);\n      this._focusBackfillItem =\n          /** @type {!HTMLElement} */ (inst.root.querySelector('*'));\n      this._itemsParent.appendChild(inst.root);\n    }\n    // Set the offcreen focused physical item.\n    this._offscreenFocusedItem = this._physicalItems[fpidx];\n    this.modelForElement(this._offscreenFocusedItem).tabIndex = 0;\n    this._physicalItems[fpidx] = this._focusBackfillItem;\n    this._focusedPhysicalIndex = fpidx;\n    // Hide the focused physical.\n    this.translate3d(0, HIDDEN_Y, 0, this._offscreenFocusedItem);\n  },\n\n  _restoreFocusedItem: function() {\n    if (!this._offscreenFocusedItem || this._focusedVirtualIndex < 0) {\n      return;\n    }\n    // Assign models to the focused index.\n    this._assignModels();\n    // Get the new physical index for the focused index.\n    var fpidx = this._focusedPhysicalIndex =\n        this._getPhysicalIndex(this._focusedVirtualIndex);\n\n    var onScreenItem = this._physicalItems[fpidx];\n    if (!onScreenItem) {\n      return;\n    }\n    var onScreenInstance = this.modelForElement(onScreenItem);\n    var offScreenInstance = this.modelForElement(this._offscreenFocusedItem);\n    // Restores the physical item only when it has the same model\n    // as the offscreen one. Use key for comparison since users can set\n    // a new item via set('items.idx').\n    if (onScreenInstance[this.as] === offScreenInstance[this.as]) {\n      // Flip the focus backfill.\n      this._focusBackfillItem = onScreenItem;\n      onScreenInstance.tabIndex = -1;\n      // Restore the focused physical item.\n      this._physicalItems[fpidx] = this._offscreenFocusedItem;\n      // Hide the physical item that backfills.\n      this.translate3d(0, HIDDEN_Y, 0, this._focusBackfillItem);\n    } else {\n      this._removeFocusedItem();\n      this._focusBackfillItem = null;\n    }\n    this._offscreenFocusedItem = null;\n  },\n\n  _didFocus: function(e) {\n    var targetModel = this.modelForElement(e.target);\n    var focusedModel = this.modelForElement(this._focusedItem);\n    var hasOffscreenFocusedItem = this._offscreenFocusedItem !== null;\n    var fidx = this._focusedVirtualIndex;\n    if (!targetModel) {\n      return;\n    }\n    if (focusedModel === targetModel) {\n      // If the user focused the same item, then bring it into view if it's not\n      // visible.\n      if (!this._isIndexVisible(fidx)) {\n        this.scrollToIndex(fidx);\n      }\n    } else {\n      this._restoreFocusedItem();\n      // Restore tabIndex for the currently focused item.\n      if (focusedModel) {\n        focusedModel.tabIndex = -1;\n      }\n      // Set the tabIndex for the next focused item.\n      targetModel.tabIndex = 0;\n      fidx = targetModel[this.indexAs];\n      this._focusedVirtualIndex = fidx;\n      this._focusedPhysicalIndex = this._getPhysicalIndex(fidx);\n      this._focusedItem = this._physicalItems[this._focusedPhysicalIndex];\n      if (hasOffscreenFocusedItem && !this._offscreenFocusedItem) {\n        this._update();\n      }\n    }\n  },\n\n  _keydownHandler: function(e) {\n    switch (e.keyCode) {\n      case /* ARROW_DOWN */ 40:\n        if (this._focusedVirtualIndex < this._virtualCount - 1)\n          e.preventDefault();\n        this._focusPhysicalItem(\n            this._focusedVirtualIndex + (this.grid ? this._itemsPerRow : 1));\n        break;\n      case /* ARROW_RIGHT */ 39:\n        if (this.grid)\n          this._focusPhysicalItem(\n              this._focusedVirtualIndex + (this._isRTL ? -1 : 1));\n        break;\n      case /* ARROW_UP */ 38:\n        if (this._focusedVirtualIndex > 0)\n          e.preventDefault();\n        this._focusPhysicalItem(\n            this._focusedVirtualIndex - (this.grid ? this._itemsPerRow : 1));\n        break;\n      case /* ARROW_LEFT */ 37:\n        if (this.grid)\n          this._focusPhysicalItem(\n              this._focusedVirtualIndex + (this._isRTL ? 1 : -1));\n        break;\n      case /* ENTER */ 13:\n        this._focusPhysicalItem(this._focusedVirtualIndex);\n        if (this.selectionEnabled)\n          this._selectionHandler(e);\n        break;\n    }\n  },\n\n  _clamp: function(v, min, max) {\n    return Math.min(max, Math.max(min, v));\n  },\n\n  _debounce: function(name, cb, asyncModule) {\n    this._debouncers = this._debouncers || {};\n    this._debouncers[name] =\n        Debouncer.debounce(this._debouncers[name], asyncModule, cb.bind(this));\n    enqueueDebouncer(this._debouncers[name]);\n  },\n\n  _forwardProperty: function(inst, name, value) {\n    inst._setPendingProperty(name, value);\n  },\n\n  /* Templatizer bindings for v2 */\n  _forwardHostPropV2: function(prop, value) {\n    (this._physicalItems || [])\n        .concat([this._offscreenFocusedItem, this._focusBackfillItem])\n        .forEach(function(item) {\n          if (item) {\n            this.modelForElement(item).forwardHostProp(prop, value);\n          }\n        }, this);\n  },\n\n  _notifyInstancePropV2: function(inst, prop, value) {\n    if (matches(this.as, prop)) {\n      var idx = inst[this.indexAs];\n      if (prop == this.as) {\n        this.items[idx] = value;\n      }\n      this.notifyPath(translate(this.as, 'items.' + idx, prop), value);\n    }\n  },\n\n  /* Templatizer bindings for v1 */\n  _getStampedChildren: function() {\n    return this._physicalItems;\n  },\n\n  _forwardInstancePath: function(inst, path, value) {\n    if (path.indexOf(this.as + '.') === 0) {\n      this.notifyPath(\n          'items.' + inst.__key__ + '.' + path.slice(this.as.length + 1),\n          value);\n    }\n  },\n\n  _forwardParentPath: function(path, value) {\n    (this._physicalItems || [])\n        .concat([this._offscreenFocusedItem, this._focusBackfillItem])\n        .forEach(function(item) {\n          if (item) {\n            this.modelForElement(item).notifyPath(path, value);\n          }\n        }, this);\n  },\n\n  _forwardParentProp: function(prop, value) {\n    (this._physicalItems || [])\n        .concat([this._offscreenFocusedItem, this._focusBackfillItem])\n        .forEach(function(item) {\n          if (item) {\n            this.modelForElement(item)[prop] = value;\n          }\n        }, this);\n  },\n\n  /* Gets the activeElement of the shadow root/host that contains the list. */\n  _getActiveElement: function() {\n    var itemsHost = this._itemsParent.node.domHost;\n    return dom(itemsHost ? itemsHost.root : document).activeElement;\n  }\n});\n", "/**\n@license\nCopyright (c) 2015 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at\nhttp://polymer.github.io/LICENSE.txt The complete set of authors may be found at\nhttp://polymer.github.io/AUTHORS.txt The complete set of contributors may be\nfound at http://polymer.github.io/CONTRIBUTORS.txt Code distributed by Google as\npart of the polymer project is also subject to an additional IP rights grant\nfound at http://polymer.github.io/PATENTS.txt\n*/\nimport '@polymer/polymer/polymer-legacy.js';\n\n/**\n * Chrome uses an older version of DOM Level 3 Keyboard Events\n *\n * Most keys are labeled as text, but some are Unicode codepoints.\n * Values taken from:\n * http://www.w3.org/TR/2007/WD-DOM-Level-3-Events-20071221/keyset.html#KeySet-Set\n */\nvar KEY_IDENTIFIER = {\n  'U+0008': 'backspace',\n  'U+0009': 'tab',\n  'U+001B': 'esc',\n  'U+0020': 'space',\n  'U+007F': 'del'\n};\n\n/**\n * Special table for KeyboardEvent.keyCode.\n * KeyboardEvent.keyIdentifier is better, and KeyBoardEvent.key is even better\n * than that.\n *\n * Values from:\n * https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent.keyCode#Value_of_keyCode\n */\nvar KEY_CODE = {\n  8: 'backspace',\n  9: 'tab',\n  13: 'enter',\n  27: 'esc',\n  33: 'pageup',\n  34: 'pagedown',\n  35: 'end',\n  36: 'home',\n  32: 'space',\n  37: 'left',\n  38: 'up',\n  39: 'right',\n  40: 'down',\n  46: 'del',\n  106: '*'\n};\n\n/**\n * MODIFIER_KEYS maps the short name for modifier keys used in a key\n * combo string to the property name that references those same keys\n * in a KeyboardEvent instance.\n */\nvar MODIFIER_KEYS = {\n  'shift': 'shiftKey',\n  'ctrl': 'ctrlKey',\n  'alt': 'altKey',\n  'meta': 'metaKey'\n};\n\n/**\n * KeyboardEvent.key is mostly represented by printable character made by\n * the keyboard, with unprintable keys labeled nicely.\n *\n * However, on OS X, Alt+char can make a Unicode character that follows an\n * Apple-specific mapping. In this case, we fall back to .keyCode.\n */\nvar KEY_CHAR = /[a-z0-9*]/;\n\n/**\n * Matches a keyIdentifier string.\n */\nvar IDENT_CHAR = /U\\+/;\n\n/**\n * Matches arrow keys in Gecko 27.0+\n */\nvar ARROW_KEY = /^arrow/;\n\n/**\n * Matches space keys everywhere (notably including IE10's exceptional name\n * `spacebar`).\n */\nvar SPACE_KEY = /^space(bar)?/;\n\n/**\n * Matches ESC key.\n *\n * Value from: http://w3c.github.io/uievents-key/#key-Escape\n */\nvar ESC_KEY = /^escape$/;\n\n/**\n * Transforms the key.\n * @param {string} key The KeyBoardEvent.key\n * @param {Boolean} [noSpecialChars] Limits the transformation to\n * alpha-numeric characters.\n */\nfunction transformKey(key, noSpecialChars) {\n  var validKey = '';\n  if (key) {\n    var lKey = key.toLowerCase();\n    if (lKey === ' ' || SPACE_KEY.test(lKey)) {\n      validKey = 'space';\n    } else if (ESC_KEY.test(lKey)) {\n      validKey = 'esc';\n    } else if (lKey.length == 1) {\n      if (!noSpecialChars || KEY_CHAR.test(lKey)) {\n        validKey = lKey;\n      }\n    } else if (ARROW_KEY.test(lKey)) {\n      validKey = lKey.replace('arrow', '');\n    } else if (lKey == 'multiply') {\n      // numpad '*' can map to Multiply on IE/Windows\n      validKey = '*';\n    } else {\n      validKey = lKey;\n    }\n  }\n  return validKey;\n}\n\nfunction transformKeyIdentifier(keyIdent) {\n  var validKey = '';\n  if (keyIdent) {\n    if (keyIdent in KEY_IDENTIFIER) {\n      validKey = KEY_IDENTIFIER[keyIdent];\n    } else if (IDENT_CHAR.test(keyIdent)) {\n      keyIdent = parseInt(keyIdent.replace('U+', '0x'), 16);\n      validKey = String.fromCharCode(keyIdent).toLowerCase();\n    } else {\n      validKey = keyIdent.toLowerCase();\n    }\n  }\n  return validKey;\n}\n\nfunction transformKeyCode(keyCode) {\n  var validKey = '';\n  if (Number(keyCode)) {\n    if (keyCode >= 65 && keyCode <= 90) {\n      // ascii a-z\n      // lowercase is 32 offset from uppercase\n      validKey = String.fromCharCode(32 + keyCode);\n    } else if (keyCode >= 112 && keyCode <= 123) {\n      // function keys f1-f12\n      validKey = 'f' + (keyCode - 112 + 1);\n    } else if (keyCode >= 48 && keyCode <= 57) {\n      // top 0-9 keys\n      validKey = String(keyCode - 48);\n    } else if (keyCode >= 96 && keyCode <= 105) {\n      // num pad 0-9\n      validKey = String(keyCode - 96);\n    } else {\n      validKey = KEY_CODE[keyCode];\n    }\n  }\n  return validKey;\n}\n\n/**\n * Calculates the normalized key for a KeyboardEvent.\n * @param {KeyboardEvent} keyEvent\n * @param {Boolean} [noSpecialChars] Set to true to limit keyEvent.key\n * transformation to alpha-numeric chars. This is useful with key\n * combinations like shift + 2, which on FF for MacOS produces\n * keyEvent.key = @\n * To get 2 returned, set noSpecialChars = true\n * To get @ returned, set noSpecialChars = false\n */\nfunction normalizedKeyForEvent(keyEvent, noSpecialChars) {\n  // Fall back from .key, to .detail.key for artifical keyboard events,\n  // and then to deprecated .keyIdentifier and .keyCode.\n  if (keyEvent.key) {\n    return transformKey(keyEvent.key, noSpecialChars);\n  }\n  if (keyEvent.detail && keyEvent.detail.key) {\n    return transformKey(keyEvent.detail.key, noSpecialChars);\n  }\n  return transformKeyIdentifier(keyEvent.keyIdentifier) ||\n      transformKeyCode(keyEvent.keyCode) || '';\n}\n\nfunction keyComboMatchesEvent(keyCombo, event) {\n  // For combos with modifiers we support only alpha-numeric keys\n  var keyEvent = normalizedKeyForEvent(event, keyCombo.hasModifiers);\n  return keyEvent === keyCombo.key &&\n      (!keyCombo.hasModifiers ||\n       (!!event.shiftKey === !!keyCombo.shiftKey &&\n        !!event.ctrlKey === !!keyCombo.ctrlKey &&\n        !!event.altKey === !!keyCombo.altKey &&\n        !!event.metaKey === !!keyCombo.metaKey));\n}\n\nfunction parseKeyComboString(keyComboString) {\n  if (keyComboString.length === 1) {\n    return {combo: keyComboString, key: keyComboString, event: 'keydown'};\n  }\n  return keyComboString.split('+')\n      .reduce(function(parsedKeyCombo, keyComboPart) {\n        var eventParts = keyComboPart.split(':');\n        var keyName = eventParts[0];\n        var event = eventParts[1];\n\n        if (keyName in MODIFIER_KEYS) {\n          parsedKeyCombo[MODIFIER_KEYS[keyName]] = true;\n          parsedKeyCombo.hasModifiers = true;\n        } else {\n          parsedKeyCombo.key = keyName;\n          parsedKeyCombo.event = event || 'keydown';\n        }\n\n        return parsedKeyCombo;\n      }, {combo: keyComboString.split(':').shift()});\n}\n\nfunction parseEventString(eventString) {\n  return eventString.trim().split(' ').map(function(keyComboString) {\n    return parseKeyComboString(keyComboString);\n  });\n}\n\n/**\n * `Polymer.IronA11yKeysBehavior` provides a normalized interface for processing\n * keyboard commands that pertain to [WAI-ARIA best\n * practices](http://www.w3.org/TR/wai-aria-practices/#kbd_general_binding). The\n * element takes care of browser differences with respect to Keyboard events and\n * uses an expressive syntax to filter key presses.\n *\n * Use the `keyBindings` prototype property to express what combination of keys\n * will trigger the callback. A key binding has the format\n * `\"KEY+MODIFIER:EVENT\": \"callback\"` (`\"KEY\": \"callback\"` or\n * `\"KEY:EVENT\": \"callback\"` are valid as well). Some examples:\n *\n *      keyBindings: {\n *        'space': '_onKeydown', // same as 'space:keydown'\n *        'shift+tab': '_onKeydown',\n *        'enter:keypress': '_onKeypress',\n *        'esc:keyup': '_onKeyup'\n *      }\n *\n * The callback will receive with an event containing the following information\n * in `event.detail`:\n *\n *      _onKeydown: function(event) {\n *        console.log(event.detail.combo); // KEY+MODIFIER, e.g. \"shift+tab\"\n *        console.log(event.detail.key); // KEY only, e.g. \"tab\"\n *        console.log(event.detail.event); // EVENT, e.g. \"keydown\"\n *        console.log(event.detail.keyboardEvent); // the original KeyboardEvent\n *      }\n *\n * Use the `keyEventTarget` attribute to set up event handlers on a specific\n * node.\n *\n * See the [demo source\n * code](https://github.com/PolymerElements/iron-a11y-keys-behavior/blob/master/demo/x-key-aware.html)\n * for an example.\n *\n * @demo demo/index.html\n * @polymerBehavior\n */\nexport const IronA11yKeysBehavior = {\n  properties: {\n    /**\n     * The EventTarget that will be firing relevant KeyboardEvents. Set it to\n     * `null` to disable the listeners.\n     * @type {?EventTarget}\n     */\n    keyEventTarget: {\n      type: Object,\n      value: function() {\n        return this;\n      }\n    },\n\n    /**\n     * If true, this property will cause the implementing element to\n     * automatically stop propagation on any handled KeyboardEvents.\n     */\n    stopKeyboardEventPropagation: {type: Boolean, value: false},\n\n    _boundKeyHandlers: {\n      type: Array,\n      value: function() {\n        return [];\n      }\n    },\n\n    // We use this due to a limitation in IE10 where instances will have\n    // own properties of everything on the \"prototype\".\n    _imperativeKeyBindings: {\n      type: Object,\n      value: function() {\n        return {};\n      }\n    }\n  },\n\n  observers: ['_resetKeyEventListeners(keyEventTarget, _boundKeyHandlers)'],\n\n\n  /**\n   * To be used to express what combination of keys  will trigger the relative\n   * callback. e.g. `keyBindings: { 'esc': '_onEscPressed'}`\n   * @type {!Object}\n   */\n  keyBindings: {},\n\n  registered: function() {\n    this._prepKeyBindings();\n  },\n\n  attached: function() {\n    this._listenKeyEventListeners();\n  },\n\n  detached: function() {\n    this._unlistenKeyEventListeners();\n  },\n\n  /**\n   * Can be used to imperatively add a key binding to the implementing\n   * element. This is the imperative equivalent of declaring a keybinding\n   * in the `keyBindings` prototype property.\n   *\n   * @param {string} eventString\n   * @param {string} handlerName\n   */\n  addOwnKeyBinding: function(eventString, handlerName) {\n    this._imperativeKeyBindings[eventString] = handlerName;\n    this._prepKeyBindings();\n    this._resetKeyEventListeners();\n  },\n\n  /**\n   * When called, will remove all imperatively-added key bindings.\n   */\n  removeOwnKeyBindings: function() {\n    this._imperativeKeyBindings = {};\n    this._prepKeyBindings();\n    this._resetKeyEventListeners();\n  },\n\n  /**\n   * Returns true if a keyboard event matches `eventString`.\n   *\n   * @param {KeyboardEvent} event\n   * @param {string} eventString\n   * @return {boolean}\n   */\n  keyboardEventMatchesKeys: function(event, eventString) {\n    var keyCombos = parseEventString(eventString);\n    for (var i = 0; i < keyCombos.length; ++i) {\n      if (keyComboMatchesEvent(keyCombos[i], event)) {\n        return true;\n      }\n    }\n    return false;\n  },\n\n  _collectKeyBindings: function() {\n    var keyBindings = this.behaviors.map(function(behavior) {\n      return behavior.keyBindings;\n    });\n\n    if (keyBindings.indexOf(this.keyBindings) === -1) {\n      keyBindings.push(this.keyBindings);\n    }\n\n    return keyBindings;\n  },\n\n  _prepKeyBindings: function() {\n    this._keyBindings = {};\n\n    this._collectKeyBindings().forEach(function(keyBindings) {\n      for (var eventString in keyBindings) {\n        this._addKeyBinding(eventString, keyBindings[eventString]);\n      }\n    }, this);\n\n    for (var eventString in this._imperativeKeyBindings) {\n      this._addKeyBinding(\n          eventString, this._imperativeKeyBindings[eventString]);\n    }\n\n    // Give precedence to combos with modifiers to be checked first.\n    for (var eventName in this._keyBindings) {\n      this._keyBindings[eventName].sort(function(kb1, kb2) {\n        var b1 = kb1[0].hasModifiers;\n        var b2 = kb2[0].hasModifiers;\n        return (b1 === b2) ? 0 : b1 ? -1 : 1;\n      })\n    }\n  },\n\n  _addKeyBinding: function(eventString, handlerName) {\n    parseEventString(eventString).forEach(function(keyCombo) {\n      this._keyBindings[keyCombo.event] =\n          this._keyBindings[keyCombo.event] || [];\n\n      this._keyBindings[keyCombo.event].push([keyCombo, handlerName]);\n    }, this);\n  },\n\n  _resetKeyEventListeners: function() {\n    this._unlistenKeyEventListeners();\n\n    if (this.isAttached) {\n      this._listenKeyEventListeners();\n    }\n  },\n\n  _listenKeyEventListeners: function() {\n    if (!this.keyEventTarget) {\n      return;\n    }\n    Object.keys(this._keyBindings).forEach(function(eventName) {\n      var keyBindings = this._keyBindings[eventName];\n      var boundKeyHandler = this._onKeyBindingEvent.bind(this, keyBindings);\n\n      this._boundKeyHandlers.push(\n          [this.keyEventTarget, eventName, boundKeyHandler]);\n\n      this.keyEventTarget.addEventListener(eventName, boundKeyHandler);\n    }, this);\n  },\n\n  _unlistenKeyEventListeners: function() {\n    var keyHandlerTuple;\n    var keyEventTarget;\n    var eventName;\n    var boundKeyHandler;\n\n    while (this._boundKeyHandlers.length) {\n      // My kingdom for block-scope binding and destructuring assignment..\n      keyHandlerTuple = this._boundKeyHandlers.pop();\n      keyEventTarget = keyHandlerTuple[0];\n      eventName = keyHandlerTuple[1];\n      boundKeyHandler = keyHandlerTuple[2];\n\n      keyEventTarget.removeEventListener(eventName, boundKeyHandler);\n    }\n  },\n\n  _onKeyBindingEvent: function(keyBindings, event) {\n    if (this.stopKeyboardEventPropagation) {\n      event.stopPropagation();\n    }\n\n    // if event has been already prevented, don't do anything\n    if (event.defaultPrevented) {\n      return;\n    }\n\n    for (var i = 0; i < keyBindings.length; i++) {\n      var keyCombo = keyBindings[i][0];\n      var handlerName = keyBindings[i][1];\n      if (keyComboMatchesEvent(keyCombo, event)) {\n        this._triggerKeyHandler(keyCombo, handlerName, event);\n        // exit the loop if eventDefault was prevented\n        if (event.defaultPrevented) {\n          return;\n        }\n      }\n    }\n  },\n\n  _triggerKeyHandler: function(keyCombo, handlerName, keyboardEvent) {\n    var detail = Object.create(keyCombo);\n    detail.keyboardEvent = keyboardEvent;\n    var event =\n        new CustomEvent(keyCombo.event, {detail: detail, cancelable: true});\n    this[handlerName].call(this, event);\n    if (event.defaultPrevented) {\n      keyboardEvent.preventDefault();\n    }\n  }\n};\n", "/**\n@license\nCopyright (c) 2015 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at\nhttp://polymer.github.io/LICENSE.txt The complete set of authors may be found at\nhttp://polymer.github.io/AUTHORS.txt The complete set of contributors may be\nfound at http://polymer.github.io/CONTRIBUTORS.txt Code distributed by Google as\npart of the polymer project is also subject to an additional IP rights grant\nfound at http://polymer.github.io/PATENTS.txt\n*/\nimport '@polymer/polymer/polymer-legacy.js';\n\nimport {dom} from '@polymer/polymer/lib/legacy/polymer.dom.js';\nimport {useShadow} from '@polymer/polymer/lib/utils/settings.js';\n\n// Contains all connected resizables that do not have a parent.\nvar ORPHANS = new Set();\n\n/**\n * `IronResizableBehavior` is a behavior that can be used in Polymer elements to\n * coordinate the flow of resize events between \"resizers\" (elements that\n *control the size or hidden state of their children) and \"resizables\" (elements\n *that need to be notified when they are resized or un-hidden by their parents\n *in order to take action on their new measurements).\n *\n * Elements that perform measurement should add the `IronResizableBehavior`\n *behavior to their element definition and listen for the `iron-resize` event on\n *themselves. This event will be fired when they become showing after having\n *been hidden, when they are resized explicitly by another resizable, or when\n *the window has been resized.\n *\n * Note, the `iron-resize` event is non-bubbling.\n *\n * @polymerBehavior\n * @demo demo/index.html\n **/\nexport const IronResizableBehavior = {\n  properties: {\n    /**\n     * The closest ancestor element that implements `IronResizableBehavior`.\n     */\n    _parentResizable: {\n      type: Object,\n      observer: '_parentResizableChanged',\n    },\n\n    /**\n     * True if this element is currently notifying its descendant elements of\n     * resize.\n     */\n    _notifyingDescendant: {\n      type: Boolean,\n      value: false,\n    }\n  },\n\n  listeners: {\n    'iron-request-resize-notifications': '_onIronRequestResizeNotifications'\n  },\n\n  created: function() {\n    // We don't really need property effects on these, and also we want them\n    // to be created before the `_parentResizable` observer fires:\n    this._interestedResizables = [];\n    this._boundNotifyResize = this.notifyResize.bind(this);\n    this._boundOnDescendantIronResize = this._onDescendantIronResize.bind(this);\n  },\n\n  attached: function() {\n    this._requestResizeNotifications();\n  },\n\n  detached: function() {\n    if (this._parentResizable) {\n      this._parentResizable.stopResizeNotificationsFor(this);\n    } else {\n      ORPHANS.delete(this);\n      window.removeEventListener('resize', this._boundNotifyResize);\n    }\n\n    this._parentResizable = null;\n  },\n\n  /**\n   * Can be called to manually notify a resizable and its descendant\n   * resizables of a resize change.\n   */\n  notifyResize: function() {\n    if (!this.isAttached) {\n      return;\n    }\n\n    this._interestedResizables.forEach(function(resizable) {\n      if (this.resizerShouldNotify(resizable)) {\n        this._notifyDescendant(resizable);\n      }\n    }, this);\n\n    this._fireResize();\n  },\n\n  /**\n   * Used to assign the closest resizable ancestor to this resizable\n   * if the ancestor detects a request for notifications.\n   */\n  assignParentResizable: function(parentResizable) {\n    if (this._parentResizable) {\n      this._parentResizable.stopResizeNotificationsFor(this);\n    }\n\n    this._parentResizable = parentResizable;\n\n    if (parentResizable &&\n        parentResizable._interestedResizables.indexOf(this) === -1) {\n      parentResizable._interestedResizables.push(this);\n      parentResizable._subscribeIronResize(this);\n    }\n  },\n\n  /**\n   * Used to remove a resizable descendant from the list of descendants\n   * that should be notified of a resize change.\n   */\n  stopResizeNotificationsFor: function(target) {\n    var index = this._interestedResizables.indexOf(target);\n\n    if (index > -1) {\n      this._interestedResizables.splice(index, 1);\n      this._unsubscribeIronResize(target);\n    }\n  },\n\n  /**\n   * Subscribe this element to listen to iron-resize events on the given target.\n   *\n   * Preferred over target.listen because the property renamer does not\n   * understand to rename when the target is not specifically \"this\"\n   *\n   * @param {!HTMLElement} target Element to listen to for iron-resize events.\n   */\n  _subscribeIronResize: function(target) {\n    target.addEventListener('iron-resize', this._boundOnDescendantIronResize);\n  },\n\n  /**\n   * Unsubscribe this element from listening to to iron-resize events on the\n   * given target.\n   *\n   * Preferred over target.unlisten because the property renamer does not\n   * understand to rename when the target is not specifically \"this\"\n   *\n   * @param {!HTMLElement} target Element to listen to for iron-resize events.\n   */\n  _unsubscribeIronResize: function(target) {\n    target.removeEventListener(\n        'iron-resize', this._boundOnDescendantIronResize);\n  },\n\n  /**\n   * This method can be overridden to filter nested elements that should or\n   * should not be notified by the current element. Return true if an element\n   * should be notified, or false if it should not be notified.\n   *\n   * @param {HTMLElement} element A candidate descendant element that\n   * implements `IronResizableBehavior`.\n   * @return {boolean} True if the `element` should be notified of resize.\n   */\n  resizerShouldNotify: function(element) {\n    return true;\n  },\n\n  _onDescendantIronResize: function(event) {\n    if (this._notifyingDescendant) {\n      event.stopPropagation();\n      return;\n    }\n\n    // no need to use this during shadow dom because of event retargeting\n    if (!useShadow) {\n      this._fireResize();\n    }\n  },\n\n  _fireResize: function() {\n    this.fire('iron-resize', null, {node: this, bubbles: false});\n  },\n\n  _onIronRequestResizeNotifications: function(event) {\n    var target = /** @type {!EventTarget} */ (dom(event).rootTarget);\n    if (target === this) {\n      return;\n    }\n\n    target.assignParentResizable(this);\n    this._notifyDescendant(target);\n\n    event.stopPropagation();\n  },\n\n  _parentResizableChanged: function(parentResizable) {\n    if (parentResizable) {\n      window.removeEventListener('resize', this._boundNotifyResize);\n    }\n  },\n\n  _notifyDescendant: function(descendant) {\n    // NOTE(cdata): In IE10, attached is fired on children first, so it's\n    // important not to notify them if the parent is not attached yet (or\n    // else they will get redundantly notified when the parent attaches).\n    if (!this.isAttached) {\n      return;\n    }\n\n    this._notifyingDescendant = true;\n    descendant.notifyResize();\n    this._notifyingDescendant = false;\n  },\n\n  _requestResizeNotifications: function() {\n    if (!this.isAttached) {\n      return;\n    }\n\n    if (document.readyState === 'loading') {\n      var _requestResizeNotifications =\n          this._requestResizeNotifications.bind(this);\n      document.addEventListener(\n          'readystatechange', function readystatechanged() {\n            document.removeEventListener('readystatechange', readystatechanged);\n            _requestResizeNotifications();\n          });\n    } else {\n      this._findParent();\n\n      if (!this._parentResizable) {\n        // If this resizable is an orphan, tell other orphans to try to find\n        // their parent again, in case it's this resizable.\n        ORPHANS.forEach(function(orphan) {\n          if (orphan !== this) {\n            orphan._findParent();\n          }\n        }, this);\n\n        window.addEventListener('resize', this._boundNotifyResize);\n        this.notifyResize();\n      } else {\n        // If this resizable has a parent, tell other child resizables of\n        // that parent to try finding their parent again, in case it's this\n        // resizable.\n        this._parentResizable._interestedResizables\n            .forEach(function(resizable) {\n              if (resizable !== this) {\n                resizable._findParent();\n              }\n            }, this);\n      }\n    }\n  },\n\n  _findParent: function() {\n    this.assignParentResizable(null);\n    this.fire(\n        'iron-request-resize-notifications',\n        null,\n        {node: this, bubbles: true, cancelable: true});\n\n    if (!this._parentResizable) {\n      ORPHANS.add(this);\n    } else {\n      ORPHANS.delete(this);\n    }\n  }\n};\n", "/**\n@license\nCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at\nhttp://polymer.github.io/LICENSE.txt The complete set of authors may be found at\nhttp://polymer.github.io/AUTHORS.txt The complete set of contributors may be\nfound at http://polymer.github.io/CONTRIBUTORS.txt Code distributed by Google as\npart of the polymer project is also subject to an additional IP rights grant\nfound at http://polymer.github.io/PATENTS.txt\n*/\nimport '@polymer/polymer/polymer-legacy.js';\n\nimport {dom} from '@polymer/polymer/lib/legacy/polymer.dom.js';\n\n/**\n * `Polymer.IronScrollTargetBehavior` allows an element to respond to scroll\n * events from a designated scroll target.\n *\n * Elements that consume this behavior can override the `_scrollHandler`\n * method to add logic on the scroll event.\n *\n * @demo demo/scrolling-region.html Scrolling Region\n * @demo demo/document.html Document Element\n * @polymerBehavior\n */\nexport const IronScrollTargetBehavior = {\n\n  properties: {\n\n    /**\n     * Specifies the element that will handle the scroll event\n     * on the behalf of the current element. This is typically a reference to an\n     *element, but there are a few more posibilities:\n     *\n     * ### Elements id\n     *\n     *```html\n     * <div id=\"scrollable-element\" style=\"overflow: auto;\">\n     *  <x-element scroll-target=\"scrollable-element\">\n     *    <!-- Content-->\n     *  </x-element>\n     * </div>\n     *```\n     * In this case, the `scrollTarget` will point to the outer div element.\n     *\n     * ### Document scrolling\n     *\n     * For document scrolling, you can use the reserved word `document`:\n     *\n     *```html\n     * <x-element scroll-target=\"document\">\n     *   <!-- Content -->\n     * </x-element>\n     *```\n     *\n     * ### Elements reference\n     *\n     *```js\n     * appHeader.scrollTarget = document.querySelector('#scrollable-element');\n     *```\n     *\n     * @type {HTMLElement}\n     * @default document\n     */\n    scrollTarget: {\n      type: HTMLElement,\n      value: function() {\n        return this._defaultScrollTarget;\n      }\n    }\n  },\n\n  observers: ['_scrollTargetChanged(scrollTarget, isAttached)'],\n\n  /**\n   * True if the event listener should be installed.\n   */\n  _shouldHaveListener: true,\n\n  _scrollTargetChanged: function(scrollTarget, isAttached) {\n    var eventTarget;\n\n    if (this._oldScrollTarget) {\n      this._toggleScrollListener(false, this._oldScrollTarget);\n      this._oldScrollTarget = null;\n    }\n    if (!isAttached) {\n      return;\n    }\n    // Support element id references\n    if (scrollTarget === 'document') {\n      this.scrollTarget = this._doc;\n\n    } else if (typeof scrollTarget === 'string') {\n      var domHost = this.domHost;\n\n      this.scrollTarget = domHost && domHost.$ ?\n          domHost.$[scrollTarget] :\n          dom(this.ownerDocument).querySelector('#' + scrollTarget);\n\n    } else if (this._isValidScrollTarget()) {\n      this._oldScrollTarget = scrollTarget;\n      this._toggleScrollListener(this._shouldHaveListener, scrollTarget);\n    }\n  },\n\n  /**\n   * Runs on every scroll event. Consumer of this behavior may override this\n   * method.\n   *\n   * @protected\n   */\n  _scrollHandler: function scrollHandler() {},\n\n  /**\n   * The default scroll target. Consumers of this behavior may want to customize\n   * the default scroll target.\n   *\n   * @type {Element}\n   */\n  get _defaultScrollTarget() {\n    return this._doc;\n  },\n\n  /**\n   * Shortcut for the document element\n   *\n   * @type {Element}\n   */\n  get _doc() {\n    return this.ownerDocument.documentElement;\n  },\n\n  /**\n   * Gets the number of pixels that the content of an element is scrolled\n   * upward.\n   *\n   * @type {number}\n   */\n  get _scrollTop() {\n    if (this._isValidScrollTarget()) {\n      return this.scrollTarget === this._doc ? window.pageYOffset :\n                                               this.scrollTarget.scrollTop;\n    }\n    return 0;\n  },\n\n  /**\n   * Gets the number of pixels that the content of an element is scrolled to the\n   * left.\n   *\n   * @type {number}\n   */\n  get _scrollLeft() {\n    if (this._isValidScrollTarget()) {\n      return this.scrollTarget === this._doc ? window.pageXOffset :\n                                               this.scrollTarget.scrollLeft;\n    }\n    return 0;\n  },\n\n  /**\n   * Sets the number of pixels that the content of an element is scrolled\n   * upward.\n   *\n   * @type {number}\n   */\n  set _scrollTop(top) {\n    if (this.scrollTarget === this._doc) {\n      window.scrollTo(window.pageXOffset, top);\n    } else if (this._isValidScrollTarget()) {\n      this.scrollTarget.scrollTop = top;\n    }\n  },\n\n  /**\n   * Sets the number of pixels that the content of an element is scrolled to the\n   * left.\n   *\n   * @type {number}\n   */\n  set _scrollLeft(left) {\n    if (this.scrollTarget === this._doc) {\n      window.scrollTo(left, window.pageYOffset);\n    } else if (this._isValidScrollTarget()) {\n      this.scrollTarget.scrollLeft = left;\n    }\n  },\n\n  /**\n   * Scrolls the content to a particular place.\n   *\n   * @method scroll\n   * @param {number|!{left: number, top: number}} leftOrOptions The left position or scroll options\n   * @param {number=} top The top position\n   * @return {void}\n   */\n  scroll: function(leftOrOptions, top) {\n    var left;\n\n    if (typeof leftOrOptions === 'object') {\n      left = leftOrOptions.left;\n      top = leftOrOptions.top;\n    } else {\n      left = leftOrOptions;\n    }\n\n    left = left || 0;\n    top = top || 0;\n    if (this.scrollTarget === this._doc) {\n      window.scrollTo(left, top);\n    } else if (this._isValidScrollTarget()) {\n      this.scrollTarget.scrollLeft = left;\n      this.scrollTarget.scrollTop = top;\n    }\n  },\n\n  /**\n   * Gets the width of the scroll target.\n   *\n   * @type {number}\n   */\n  get _scrollTargetWidth() {\n    if (this._isValidScrollTarget()) {\n      return this.scrollTarget === this._doc ? window.innerWidth :\n                                               this.scrollTarget.offsetWidth;\n    }\n    return 0;\n  },\n\n  /**\n   * Gets the height of the scroll target.\n   *\n   * @type {number}\n   */\n  get _scrollTargetHeight() {\n    if (this._isValidScrollTarget()) {\n      return this.scrollTarget === this._doc ? window.innerHeight :\n                                               this.scrollTarget.offsetHeight;\n    }\n    return 0;\n  },\n\n  /**\n   * Returns true if the scroll target is a valid HTMLElement.\n   *\n   * @return {boolean}\n   */\n  _isValidScrollTarget: function() {\n    return this.scrollTarget instanceof HTMLElement;\n  },\n\n  _toggleScrollListener: function(yes, scrollTarget) {\n    var eventTarget = scrollTarget === this._doc ? window : scrollTarget;\n    if (yes) {\n      if (!this._boundScrollHandler) {\n        this._boundScrollHandler = this._scrollHandler.bind(this);\n        eventTarget.addEventListener('scroll', this._boundScrollHandler);\n      }\n    } else {\n      if (this._boundScrollHandler) {\n        eventTarget.removeEventListener('scroll', this._boundScrollHandler);\n        this._boundScrollHandler = null;\n      }\n    }\n  },\n\n  /**\n   * Enables or disables the scroll event listener.\n   *\n   * @param {boolean} yes True to add the event, False to remove it.\n   */\n  toggleScrollListener: function(yes) {\n    this._shouldHaveListener = yes;\n    this._toggleScrollListener(yes, this.scrollTarget);\n  }\n\n};\n"],
  "mappings": "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",
  "names": ["dom", "dom"]
}
